import { __commonJS } from "./chunk-DbKvDyjX.js";

//#region node_modules/papaparse/papaparse.min.js
var require_papaparse_min = /* @__PURE__ */ __commonJS({ "node_modules/papaparse/papaparse.min.js": ((exports, module) => {
	/* @license
	Papa Parse
	v5.5.3
	https://github.com/mholt/PapaParse
	License: MIT
	*/
	((e, t) => {
		"function" == typeof define && define.amd ? define([], t) : "object" == typeof module && "undefined" != typeof exports ? module.exports = t() : e.Papa = t();
	})(exports, function r() {
		var n = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== n ? n : {};
		var d, s = !n.document && !!n.postMessage, a = n.IS_PAPA_WORKER || !1, o = {}, h = 0, v = {};
		function u(e) {
			this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = {
				data: [],
				errors: [],
				meta: {}
			}, function(e$1) {
				var t = b(e$1);
				t.chunkSize = parseInt(t.chunkSize), e$1.step || e$1.chunk || (t.chunkSize = null);
				this._handle = new i(t), (this._handle.streamer = this)._config = t;
			}.call(this, e), this.parseChunk = function(t, e$1) {
				var i$1 = parseInt(this._config.skipFirstNLines) || 0;
				if (this.isFirstChunk && 0 < i$1) {
					let e$2 = this._config.newline;
					e$2 || (r$1 = this._config.quoteChar || "\"", e$2 = this._handle.guessLineEndings(t, r$1)), t = [...t.split(e$2).slice(i$1)].join(e$2);
				}
				this.isFirstChunk && U(this._config.beforeFirstChunk) && void 0 !== (r$1 = this._config.beforeFirstChunk(t)) && (t = r$1), this.isFirstChunk = !1, this._halted = !1;
				var i$1 = this._partialLine + t, r$1 = (this._partialLine = "", this._handle.parse(i$1, this._baseIndex, !this._finished));
				if (!this._handle.paused() && !this._handle.aborted()) {
					t = r$1.meta.cursor, i$1 = (this._finished || (this._partialLine = i$1.substring(t - this._baseIndex), this._baseIndex = t), r$1 && r$1.data && (this._rowCount += r$1.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview);
					if (a) n.postMessage({
						results: r$1,
						workerId: v.WORKER_ID,
						finished: i$1
					});
					else if (U(this._config.chunk) && !e$1) {
						if (this._config.chunk(r$1, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = !0);
						this._completeResults = r$1 = void 0;
					}
					return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(r$1.data), this._completeResults.errors = this._completeResults.errors.concat(r$1.errors), this._completeResults.meta = r$1.meta), this._completed || !i$1 || !U(this._config.complete) || r$1 && r$1.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), i$1 || r$1 && r$1.meta.paused || this._nextChunk(), r$1;
				}
				this._halted = !0;
			}, this._sendError = function(e$1) {
				U(this._config.error) ? this._config.error(e$1) : a && this._config.error && n.postMessage({
					workerId: v.WORKER_ID,
					error: e$1,
					finished: !1
				});
			};
		}
		function f(e) {
			var r$1;
			(e = e || {}).chunkSize || (e.chunkSize = v.RemoteChunkSize), u.call(this, e), this._nextChunk = s ? function() {
				this._readChunk(), this._chunkLoaded();
			} : function() {
				this._readChunk();
			}, this.stream = function(e$1) {
				this._input = e$1, this._nextChunk();
			}, this._readChunk = function() {
				if (this._finished) this._chunkLoaded();
				else {
					if (r$1 = new XMLHttpRequest(), this._config.withCredentials && (r$1.withCredentials = this._config.withCredentials), s || (r$1.onload = y(this._chunkLoaded, this), r$1.onerror = y(this._chunkError, this)), r$1.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !s), this._config.downloadRequestHeaders) {
						var e$1, t = this._config.downloadRequestHeaders;
						for (e$1 in t) r$1.setRequestHeader(e$1, t[e$1]);
					}
					var i$1;
					this._config.chunkSize && (i$1 = this._start + this._config.chunkSize - 1, r$1.setRequestHeader("Range", "bytes=" + this._start + "-" + i$1));
					try {
						r$1.send(this._config.downloadRequestBody);
					} catch (e$2) {
						this._chunkError(e$2.message);
					}
					s && 0 === r$1.status && this._chunkError();
				}
			}, this._chunkLoaded = function() {
				4 === r$1.readyState && (r$1.status < 200 || 400 <= r$1.status ? this._chunkError() : (this._start += this._config.chunkSize || r$1.responseText.length, this._finished = !this._config.chunkSize || this._start >= ((e$1) => null !== (e$1 = e$1.getResponseHeader("Content-Range")) ? parseInt(e$1.substring(e$1.lastIndexOf("/") + 1)) : -1)(r$1), this.parseChunk(r$1.responseText)));
			}, this._chunkError = function(e$1) {
				e$1 = r$1.statusText || e$1;
				this._sendError(new Error(e$1));
			};
		}
		function l(e) {
			(e = e || {}).chunkSize || (e.chunkSize = v.LocalChunkSize), u.call(this, e);
			var i$1, r$1, n$1 = "undefined" != typeof FileReader;
			this.stream = function(e$1) {
				this._input = e$1, r$1 = e$1.slice || e$1.webkitSlice || e$1.mozSlice, n$1 ? ((i$1 = new FileReader()).onload = y(this._chunkLoaded, this), i$1.onerror = y(this._chunkError, this)) : i$1 = new FileReaderSync(), this._nextChunk();
			}, this._nextChunk = function() {
				this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
			}, this._readChunk = function() {
				var e$1 = this._input, t = (this._config.chunkSize && (t = Math.min(this._start + this._config.chunkSize, this._input.size), e$1 = r$1.call(e$1, this._start, t)), i$1.readAsText(e$1, this._config.encoding));
				n$1 || this._chunkLoaded({ target: { result: t } });
			}, this._chunkLoaded = function(e$1) {
				this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e$1.target.result);
			}, this._chunkError = function() {
				this._sendError(i$1.error);
			};
		}
		function c(e) {
			var i$1;
			u.call(this, e = e || {}), this.stream = function(e$1) {
				return i$1 = e$1, this._nextChunk();
			}, this._nextChunk = function() {
				var e$1, t;
				if (!this._finished) return e$1 = this._config.chunkSize, i$1 = e$1 ? (t = i$1.substring(0, e$1), i$1.substring(e$1)) : (t = i$1, ""), this._finished = !i$1, this.parseChunk(t);
			};
		}
		function p(e) {
			u.call(this, e = e || {});
			var t = [], i$1 = !0, r$1 = !1;
			this.pause = function() {
				u.prototype.pause.apply(this, arguments), this._input.pause();
			}, this.resume = function() {
				u.prototype.resume.apply(this, arguments), this._input.resume();
			}, this.stream = function(e$1) {
				this._input = e$1, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
			}, this._checkIsFinished = function() {
				r$1 && 1 === t.length && (this._finished = !0);
			}, this._nextChunk = function() {
				this._checkIsFinished(), t.length ? this.parseChunk(t.shift()) : i$1 = !0;
			}, this._streamData = y(function(e$1) {
				try {
					t.push("string" == typeof e$1 ? e$1 : e$1.toString(this._config.encoding)), i$1 && (i$1 = !1, this._checkIsFinished(), this.parseChunk(t.shift()));
				} catch (e$2) {
					this._streamError(e$2);
				}
			}, this), this._streamError = y(function(e$1) {
				this._streamCleanUp(), this._sendError(e$1);
			}, this), this._streamEnd = y(function() {
				this._streamCleanUp(), r$1 = !0, this._streamData("");
			}, this), this._streamCleanUp = y(function() {
				this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
			}, this);
		}
		function i(m$1) {
			var n$1, s$1, a$1, t, o$1 = Math.pow(2, 53), h$1 = -o$1, u$1 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, d$1 = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, i$1 = this, r$1 = 0, f$1 = 0, l$1 = !1, e = !1, c$1 = [], p$1 = {
				data: [],
				errors: [],
				meta: {}
			};
			function y$1(e$1) {
				return "greedy" === m$1.skipEmptyLines ? "" === e$1.join("").trim() : 1 === e$1.length && 0 === e$1[0].length;
			}
			function g$1() {
				if (p$1 && a$1 && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + v.DefaultDelimiter + "'"), a$1 = !1), m$1.skipEmptyLines && (p$1.data = p$1.data.filter(function(e$2) {
					return !y$1(e$2);
				})), _$1()) {
					if (p$1) if (Array.isArray(p$1.data[0])) {
						for (var e$1 = 0; _$1() && e$1 < p$1.data.length; e$1++) p$1.data[e$1].forEach(t$1);
						p$1.data.splice(0, 1);
					} else p$1.data.forEach(t$1);
					function t$1(e$2, t$2) {
						U(m$1.transformHeader) && (e$2 = m$1.transformHeader(e$2, t$2)), c$1.push(e$2);
					}
				}
				function i$2(e$2, t$1) {
					for (var i$3 = m$1.header ? {} : [], r$3 = 0; r$3 < e$2.length; r$3++) {
						var n$2 = r$3, s$2 = e$2[r$3], s$2 = ((e$3, t$2) => ((e$4) => (m$1.dynamicTypingFunction && void 0 === m$1.dynamicTyping[e$4] && (m$1.dynamicTyping[e$4] = m$1.dynamicTypingFunction(e$4)), !0 === (m$1.dynamicTyping[e$4] || m$1.dynamicTyping)))(e$3) ? "true" === t$2 || "TRUE" === t$2 || "false" !== t$2 && "FALSE" !== t$2 && (((e$4) => {
							if (u$1.test(e$4)) {
								e$4 = parseFloat(e$4);
								if (h$1 < e$4 && e$4 < o$1) return 1;
							}
						})(t$2) ? parseFloat(t$2) : d$1.test(t$2) ? new Date(t$2) : "" === t$2 ? null : t$2) : t$2)(n$2 = m$1.header ? r$3 >= c$1.length ? "__parsed_extra" : c$1[r$3] : n$2, s$2 = m$1.transform ? m$1.transform(s$2, n$2) : s$2);
						"__parsed_extra" === n$2 ? (i$3[n$2] = i$3[n$2] || [], i$3[n$2].push(s$2)) : i$3[n$2] = s$2;
					}
					return m$1.header && (r$3 > c$1.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + c$1.length + " fields but parsed " + r$3, f$1 + t$1) : r$3 < c$1.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + c$1.length + " fields but parsed " + r$3, f$1 + t$1)), i$3;
				}
				var r$2;
				p$1 && (m$1.header || m$1.dynamicTyping || m$1.transform) && (r$2 = 1, !p$1.data.length || Array.isArray(p$1.data[0]) ? (p$1.data = p$1.data.map(i$2), r$2 = p$1.data.length) : p$1.data = i$2(p$1.data, 0), m$1.header && p$1.meta && (p$1.meta.fields = c$1), f$1 += r$2);
			}
			function _$1() {
				return m$1.header && 0 === c$1.length;
			}
			function k(e$1, t$1, i$2, r$2) {
				e$1 = {
					type: e$1,
					code: t$1,
					message: i$2
				};
				void 0 !== r$2 && (e$1.row = r$2), p$1.errors.push(e$1);
			}
			U(m$1.step) && (t = m$1.step, m$1.step = function(e$1) {
				p$1 = e$1, _$1() ? g$1() : (g$1(), 0 !== p$1.data.length && (r$1 += e$1.data.length, m$1.preview && r$1 > m$1.preview ? s$1.abort() : (p$1.data = p$1.data[0], t(p$1, i$1))));
			}), this.parse = function(e$1, t$1, i$2) {
				var r$2 = m$1.quoteChar || "\"", r$2 = (m$1.newline || (m$1.newline = this.guessLineEndings(e$1, r$2)), a$1 = !1, m$1.delimiter ? U(m$1.delimiter) && (m$1.delimiter = m$1.delimiter(e$1), p$1.meta.delimiter = m$1.delimiter) : ((r$2 = ((e$2, t$2, i$3, r$3, n$2) => {
					var s$2, a$2, o$2, h$2;
					n$2 = n$2 || [
						",",
						"	",
						"|",
						";",
						v.RECORD_SEP,
						v.UNIT_SEP
					];
					for (var u$2 = 0; u$2 < n$2.length; u$2++) {
						for (var d$2, f$2 = n$2[u$2], l$2 = 0, c$2 = 0, p$2 = 0, g$2 = (o$2 = void 0, new E({
							comments: r$3,
							delimiter: f$2,
							newline: t$2,
							preview: 10
						}).parse(e$2)), _$2 = 0; _$2 < g$2.data.length; _$2++) i$3 && y$1(g$2.data[_$2]) ? p$2++ : (d$2 = g$2.data[_$2].length, c$2 += d$2, void 0 === o$2 ? o$2 = d$2 : 0 < d$2 && (l$2 += Math.abs(d$2 - o$2), o$2 = d$2));
						0 < g$2.data.length && (c$2 /= g$2.data.length - p$2), (void 0 === a$2 || l$2 <= a$2) && (void 0 === h$2 || h$2 < c$2) && 1.99 < c$2 && (a$2 = l$2, s$2 = f$2, h$2 = c$2);
					}
					return {
						successful: !!(m$1.delimiter = s$2),
						bestDelimiter: s$2
					};
				})(e$1, m$1.newline, m$1.skipEmptyLines, m$1.comments, m$1.delimitersToGuess)).successful ? m$1.delimiter = r$2.bestDelimiter : (a$1 = !0, m$1.delimiter = v.DefaultDelimiter), p$1.meta.delimiter = m$1.delimiter), b(m$1));
				return m$1.preview && m$1.header && r$2.preview++, n$1 = e$1, s$1 = new E(r$2), p$1 = s$1.parse(n$1, t$1, i$2), g$1(), l$1 ? { meta: { paused: !0 } } : p$1 || { meta: { paused: !1 } };
			}, this.paused = function() {
				return l$1;
			}, this.pause = function() {
				l$1 = !0, s$1.abort(), n$1 = U(m$1.chunk) ? "" : n$1.substring(s$1.getCharIndex());
			}, this.resume = function() {
				i$1.streamer._halted ? (l$1 = !1, i$1.streamer.parseChunk(n$1, !0)) : setTimeout(i$1.resume, 3);
			}, this.aborted = function() {
				return e;
			}, this.abort = function() {
				e = !0, s$1.abort(), p$1.meta.aborted = !0, U(m$1.complete) && m$1.complete(p$1), n$1 = "";
			}, this.guessLineEndings = function(e$1, t$1) {
				e$1 = e$1.substring(0, 1048576);
				var t$1 = new RegExp(P(t$1) + "([^]*?)" + P(t$1), "gm"), i$2 = (e$1 = e$1.replace(t$1, "")).split("\r"), t$1 = e$1.split("\n"), e$1 = 1 < t$1.length && t$1[0].length < i$2[0].length;
				if (1 === i$2.length || e$1) return "\n";
				for (var r$2 = 0, n$2 = 0; n$2 < i$2.length; n$2++) "\n" === i$2[n$2][0] && r$2++;
				return r$2 >= i$2.length / 2 ? "\r\n" : "\r";
			};
		}
		function P(e) {
			return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
		}
		function E(C) {
			var S = (C = C || {}).delimiter, O = C.newline, x = C.comments, I = C.step, A = C.preview, T = C.fastMode, D = null, L = !1, F = null == C.quoteChar ? "\"" : C.quoteChar, j = F;
			if (void 0 !== C.escapeChar && (j = C.escapeChar), ("string" != typeof S || -1 < v.BAD_DELIMITERS.indexOf(S)) && (S = ","), x === S) throw new Error("Comment character same as delimiter");
			!0 === x ? x = "#" : ("string" != typeof x || -1 < v.BAD_DELIMITERS.indexOf(x)) && (x = !1), "\n" !== O && "\r" !== O && "\r\n" !== O && (O = "\n");
			var z = 0, M = !1;
			this.parse = function(i$1, t, r$1) {
				if ("string" != typeof i$1) throw new Error("Input must be a string");
				var n$1 = i$1.length, e = S.length, s$1 = O.length, a$1 = x.length, o$1 = U(I), h$1 = [], u$1 = [], d$1 = [], f$1 = z = 0;
				if (!i$1) return w();
				if (T || !1 !== T && -1 === i$1.indexOf(F)) {
					for (var l$1 = i$1.split(O), c$1 = 0; c$1 < l$1.length; c$1++) {
						if (d$1 = l$1[c$1], z += d$1.length, c$1 !== l$1.length - 1) z += O.length;
						else if (r$1) return w();
						if (!x || d$1.substring(0, a$1) !== x) {
							if (o$1) {
								if (h$1 = [], k(d$1.split(S)), R(), M) return w();
							} else k(d$1.split(S));
							if (A && A <= c$1) return h$1 = h$1.slice(0, A), w(!0);
						}
					}
					return w();
				}
				for (var p$1 = i$1.indexOf(S, z), g$1 = i$1.indexOf(O, z), _$1 = new RegExp(P(j) + P(F), "g"), m$1 = i$1.indexOf(F, z);;) if (i$1[z] === F) for (m$1 = z, z++;;) {
					if (-1 === (m$1 = i$1.indexOf(F, m$1 + 1))) return r$1 || u$1.push({
						type: "Quotes",
						code: "MissingQuotes",
						message: "Quoted field unterminated",
						row: h$1.length,
						index: z
					}), E$1();
					if (m$1 === n$1 - 1) return E$1(i$1.substring(z, m$1).replace(_$1, F));
					if (F === j && i$1[m$1 + 1] === j) m$1++;
					else if (F === j || 0 === m$1 || i$1[m$1 - 1] !== j) {
						-1 !== p$1 && p$1 < m$1 + 1 && (p$1 = i$1.indexOf(S, m$1 + 1));
						var y$1 = v$1(-1 === (g$1 = -1 !== g$1 && g$1 < m$1 + 1 ? i$1.indexOf(O, m$1 + 1) : g$1) ? p$1 : Math.min(p$1, g$1));
						if (i$1.substr(m$1 + 1 + y$1, e) === S) {
							d$1.push(i$1.substring(z, m$1).replace(_$1, F)), i$1[z = m$1 + 1 + y$1 + e] !== F && (m$1 = i$1.indexOf(F, z)), p$1 = i$1.indexOf(S, z), g$1 = i$1.indexOf(O, z);
							break;
						}
						y$1 = v$1(g$1);
						if (i$1.substring(m$1 + 1 + y$1, m$1 + 1 + y$1 + s$1) === O) {
							if (d$1.push(i$1.substring(z, m$1).replace(_$1, F)), b$1(m$1 + 1 + y$1 + s$1), p$1 = i$1.indexOf(S, z), m$1 = i$1.indexOf(F, z), o$1 && (R(), M)) return w();
							if (A && h$1.length >= A) return w(!0);
							break;
						}
						u$1.push({
							type: "Quotes",
							code: "InvalidQuotes",
							message: "Trailing quote on quoted field is malformed",
							row: h$1.length,
							index: z
						}), m$1++;
					}
				}
				else if (x && 0 === d$1.length && i$1.substring(z, z + a$1) === x) {
					if (-1 === g$1) return w();
					z = g$1 + s$1, g$1 = i$1.indexOf(O, z), p$1 = i$1.indexOf(S, z);
				} else if (-1 !== p$1 && (p$1 < g$1 || -1 === g$1)) d$1.push(i$1.substring(z, p$1)), z = p$1 + e, p$1 = i$1.indexOf(S, z);
				else {
					if (-1 === g$1) break;
					if (d$1.push(i$1.substring(z, g$1)), b$1(g$1 + s$1), o$1 && (R(), M)) return w();
					if (A && h$1.length >= A) return w(!0);
				}
				return E$1();
				function k(e$1) {
					h$1.push(e$1), f$1 = z;
				}
				function v$1(e$1) {
					var t$1 = 0;
					return t$1 = -1 !== e$1 && (e$1 = i$1.substring(m$1 + 1, e$1)) && "" === e$1.trim() ? e$1.length : t$1;
				}
				function E$1(e$1) {
					return r$1 || (void 0 === e$1 && (e$1 = i$1.substring(z)), d$1.push(e$1), z = n$1, k(d$1), o$1 && R()), w();
				}
				function b$1(e$1) {
					z = e$1, k(d$1), d$1 = [], g$1 = i$1.indexOf(O, z);
				}
				function w(e$1) {
					if (C.header && !t && h$1.length && !L) {
						var s$2 = h$1[0], a$2 = Object.create(null), o$2 = new Set(s$2);
						let n$2 = !1;
						for (let r$2 = 0; r$2 < s$2.length; r$2++) {
							let i$2 = s$2[r$2];
							if (a$2[i$2 = U(C.transformHeader) ? C.transformHeader(i$2, r$2) : i$2]) {
								let e$2, t$1 = a$2[i$2];
								for (; e$2 = i$2 + "_" + t$1, t$1++, o$2.has(e$2););
								o$2.add(e$2), s$2[r$2] = e$2, a$2[i$2]++, n$2 = !0, (D = null === D ? {} : D)[e$2] = i$2;
							} else a$2[i$2] = 1, s$2[r$2] = i$2;
							o$2.add(i$2);
						}
						n$2 && console.warn("Duplicate headers found and renamed."), L = !0;
					}
					return {
						data: h$1,
						errors: u$1,
						meta: {
							delimiter: S,
							linebreak: O,
							aborted: M,
							truncated: !!e$1,
							cursor: f$1 + (t || 0),
							renamedHeaders: D
						}
					};
				}
				function R() {
					I(w()), h$1 = [], u$1 = [];
				}
			}, this.abort = function() {
				M = !0;
			}, this.getCharIndex = function() {
				return z;
			};
		}
		function g(e) {
			var t = e.data, i$1 = o[t.workerId], r$1 = !1;
			if (t.error) i$1.userError(t.error, t.file);
			else if (t.results && t.results.data) {
				var n$1 = {
					abort: function() {
						r$1 = !0, _(t.workerId, {
							data: [],
							errors: [],
							meta: { aborted: !0 }
						});
					},
					pause: m,
					resume: m
				};
				if (U(i$1.userStep)) {
					for (var s$1 = 0; s$1 < t.results.data.length && (i$1.userStep({
						data: t.results.data[s$1],
						errors: t.results.errors,
						meta: t.results.meta
					}, n$1), !r$1); s$1++);
					delete t.results;
				} else U(i$1.userChunk) && (i$1.userChunk(t.results, n$1, t.file), delete t.results);
			}
			t.finished && !r$1 && _(t.workerId, t.results);
		}
		function _(e, t) {
			var i$1 = o[e];
			U(i$1.userComplete) && i$1.userComplete(t), i$1.terminate(), delete o[e];
		}
		function m() {
			throw new Error("Not implemented.");
		}
		function b(e) {
			if ("object" != typeof e || null === e) return e;
			var t, i$1 = Array.isArray(e) ? [] : {};
			for (t in e) i$1[t] = b(e[t]);
			return i$1;
		}
		function y(e, t) {
			return function() {
				e.apply(t, arguments);
			};
		}
		function U(e) {
			return "function" == typeof e;
		}
		return v.parse = function(e, t) {
			var i$1 = (t = t || {}).dynamicTyping || !1;
			U(i$1) && (t.dynamicTypingFunction = i$1, i$1 = {});
			if (t.dynamicTyping = i$1, t.transform = !!U(t.transform) && t.transform, !t.worker || !v.WORKERS_SUPPORTED) return i$1 = null, v.NODE_STREAM_INPUT, "string" == typeof e ? (e = ((e$1) => 65279 !== e$1.charCodeAt(0) ? e$1 : e$1.slice(1))(e), i$1 = new (t.download ? f : c)(t)) : !0 === e.readable && U(e.read) && U(e.on) ? i$1 = new p(t) : (n.File && e instanceof File || e instanceof Object) && (i$1 = new l(t)), i$1.stream(e);
			(i$1 = (() => {
				var e$1;
				return !!v.WORKERS_SUPPORTED && (e$1 = (() => {
					var e$2 = n.URL || n.webkitURL || null, t$1 = r.toString();
					return v.BLOB_URL || (v.BLOB_URL = e$2.createObjectURL(new Blob([
						"var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ",
						"(",
						t$1,
						")();"
					], { type: "text/javascript" })));
				})(), (e$1 = new n.Worker(e$1)).onmessage = g, e$1.id = h++, o[e$1.id] = e$1);
			})()).userStep = t.step, i$1.userChunk = t.chunk, i$1.userComplete = t.complete, i$1.userError = t.error, t.step = U(t.step), t.chunk = U(t.chunk), t.complete = U(t.complete), t.error = U(t.error), delete t.worker, i$1.postMessage({
				input: e,
				config: t,
				workerId: i$1.id
			});
		}, v.unparse = function(e, t) {
			var n$1 = !1, _$1 = !0, m$1 = ",", y$1 = "\r\n", s$1 = "\"", a$1 = s$1 + s$1, i$1 = !1, r$1 = null, o$1 = !1, h$1 = ((() => {
				if ("object" == typeof t) {
					if ("string" != typeof t.delimiter || v.BAD_DELIMITERS.filter(function(e$1) {
						return -1 !== t.delimiter.indexOf(e$1);
					}).length || (m$1 = t.delimiter), "boolean" != typeof t.quotes && "function" != typeof t.quotes && !Array.isArray(t.quotes) || (n$1 = t.quotes), "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (i$1 = t.skipEmptyLines), "string" == typeof t.newline && (y$1 = t.newline), "string" == typeof t.quoteChar && (s$1 = t.quoteChar), "boolean" == typeof t.header && (_$1 = t.header), Array.isArray(t.columns)) {
						if (0 === t.columns.length) throw new Error("Option columns is empty");
						r$1 = t.columns;
					}
					void 0 !== t.escapeChar && (a$1 = t.escapeChar + s$1), t.escapeFormulae instanceof RegExp ? o$1 = t.escapeFormulae : "boolean" == typeof t.escapeFormulae && t.escapeFormulae && (o$1 = /^[=+\-@\t\r].*$/);
				}
			})(), new RegExp(P(s$1), "g"));
			"string" == typeof e && (e = JSON.parse(e));
			if (Array.isArray(e)) {
				if (!e.length || Array.isArray(e[0])) return u$1(null, e, i$1);
				if ("object" == typeof e[0]) return u$1(r$1 || Object.keys(e[0]), e, i$1);
			} else if ("object" == typeof e) return "string" == typeof e.data && (e.data = JSON.parse(e.data)), Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || r$1), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : "object" == typeof e.data[0] ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || "object" == typeof e.data[0] || (e.data = [e.data])), u$1(e.fields || [], e.data || [], i$1);
			throw new Error("Unable to serialize unrecognized input");
			function u$1(e$1, t$1, i$2) {
				var r$2 = "", n$2 = ("string" == typeof e$1 && (e$1 = JSON.parse(e$1)), "string" == typeof t$1 && (t$1 = JSON.parse(t$1)), Array.isArray(e$1) && 0 < e$1.length), s$2 = !Array.isArray(t$1[0]);
				if (n$2 && _$1) {
					for (var a$2 = 0; a$2 < e$1.length; a$2++) 0 < a$2 && (r$2 += m$1), r$2 += k(e$1[a$2], a$2);
					0 < t$1.length && (r$2 += y$1);
				}
				for (var o$2 = 0; o$2 < t$1.length; o$2++) {
					var h$2 = (n$2 ? e$1 : t$1[o$2]).length, u$2 = !1, d$1 = n$2 ? 0 === Object.keys(t$1[o$2]).length : 0 === t$1[o$2].length;
					if (i$2 && !n$2 && (u$2 = "greedy" === i$2 ? "" === t$1[o$2].join("").trim() : 1 === t$1[o$2].length && 0 === t$1[o$2][0].length), "greedy" === i$2 && n$2) {
						for (var f$1 = [], l$1 = 0; l$1 < h$2; l$1++) {
							var c$1 = s$2 ? e$1[l$1] : l$1;
							f$1.push(t$1[o$2][c$1]);
						}
						u$2 = "" === f$1.join("").trim();
					}
					if (!u$2) {
						for (var p$1 = 0; p$1 < h$2; p$1++) {
							0 < p$1 && !d$1 && (r$2 += m$1);
							var g$1 = n$2 && s$2 ? e$1[p$1] : p$1;
							r$2 += k(t$1[o$2][g$1], p$1);
						}
						o$2 < t$1.length - 1 && (!i$2 || 0 < h$2 && !d$1) && (r$2 += y$1);
					}
				}
				return r$2;
			}
			function k(e$1, t$1) {
				var i$2, r$2;
				return null == e$1 ? "" : e$1.constructor === Date ? JSON.stringify(e$1).slice(1, 25) : (r$2 = !1, o$1 && "string" == typeof e$1 && o$1.test(e$1) && (e$1 = "'" + e$1, r$2 = !0), i$2 = e$1.toString().replace(h$1, a$1), (r$2 = r$2 || !0 === n$1 || "function" == typeof n$1 && n$1(e$1, t$1) || Array.isArray(n$1) && n$1[t$1] || ((e$2, t$2) => {
					for (var i$3 = 0; i$3 < t$2.length; i$3++) if (-1 < e$2.indexOf(t$2[i$3])) return !0;
					return !1;
				})(i$2, v.BAD_DELIMITERS) || -1 < i$2.indexOf(m$1) || " " === i$2.charAt(0) || " " === i$2.charAt(i$2.length - 1)) ? s$1 + i$2 + s$1 : i$2);
			}
		}, v.RECORD_SEP = String.fromCharCode(30), v.UNIT_SEP = String.fromCharCode(31), v.BYTE_ORDER_MARK = "ï»¿", v.BAD_DELIMITERS = [
			"\r",
			"\n",
			"\"",
			v.BYTE_ORDER_MARK
		], v.WORKERS_SUPPORTED = !s && !!n.Worker, v.NODE_STREAM_INPUT = 1, v.LocalChunkSize = 10485760, v.RemoteChunkSize = 5242880, v.DefaultDelimiter = ",", v.Parser = E, v.ParserHandle = i, v.NetworkStreamer = f, v.FileStreamer = l, v.StringStreamer = c, v.ReadableStreamStreamer = p, n.jQuery && ((d = n.jQuery).fn.parse = function(o$1) {
			var i$1 = o$1.config || {}, h$1 = [];
			return this.each(function(e$1) {
				if (!("INPUT" === d(this).prop("tagName").toUpperCase() && "file" === d(this).attr("type").toLowerCase() && n.FileReader) || !this.files || 0 === this.files.length) return !0;
				for (var t = 0; t < this.files.length; t++) h$1.push({
					file: this.files[t],
					inputElem: this,
					instanceConfig: d.extend({}, i$1)
				});
			}), e(), this;
			function e() {
				if (0 === h$1.length) U(o$1.complete) && o$1.complete();
				else {
					var e$1, t, i$2, r$1, n$1 = h$1[0];
					if (U(o$1.before)) {
						var s$1 = o$1.before(n$1.file, n$1.inputElem);
						if ("object" == typeof s$1) {
							if ("abort" === s$1.action) return e$1 = "AbortError", t = n$1.file, i$2 = n$1.inputElem, r$1 = s$1.reason, void (U(o$1.error) && o$1.error({ name: e$1 }, t, i$2, r$1));
							if ("skip" === s$1.action) return void u$1();
							"object" == typeof s$1.config && (n$1.instanceConfig = d.extend(n$1.instanceConfig, s$1.config));
						} else if ("skip" === s$1) return void u$1();
					}
					var a$1 = n$1.instanceConfig.complete;
					n$1.instanceConfig.complete = function(e$2) {
						U(a$1) && a$1(e$2, n$1.file, n$1.inputElem), u$1();
					}, v.parse(n$1.file, n$1.instanceConfig);
				}
			}
			function u$1() {
				h$1.splice(0, 1), e();
			}
		}), a && (n.onmessage = function(e) {
			e = e.data;
			void 0 === v.WORKER_ID && e && (v.WORKER_ID = e.workerId);
			"string" == typeof e.input ? n.postMessage({
				workerId: v.WORKER_ID,
				results: v.parse(e.input, e.config),
				finished: !0
			}) : (n.File && e.input instanceof File || e.input instanceof Object) && (e = v.parse(e.input, e.config)) && n.postMessage({
				workerId: v.WORKER_ID,
				results: e,
				finished: !0
			});
		}), (f.prototype = Object.create(u.prototype)).constructor = f, (l.prototype = Object.create(u.prototype)).constructor = l, (c.prototype = Object.create(c.prototype)).constructor = c, (p.prototype = Object.create(u.prototype)).constructor = p, v;
	});
}) });

//#endregion
export default require_papaparse_min();

//# sourceMappingURL=papaparse.js.map